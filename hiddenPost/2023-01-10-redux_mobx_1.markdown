---
layout: post
title: "redux and mobX (둘다 배우자!) - 01"
date: 2023-01-10 21:50:00 +0100
categories:
---

# redux & mobX (둘다 배우자!) - 01

&nbsp;

redux / mobX 등의 상태 관리 라이브러리를 사용하는 이유는, 기본적으로 React가 단방향으로 설계되었기 때문이다.

&nbsp;

단방향으로만 데이터가 흐른다는 것은, 간단하게 이야기하자면 부모로부터 자식으로만 데이터 전달이 가능하다는 것이다.
단방향 데이터 흐름으로 인해 리액트는 관리의 편의성, virtual dom의 특성상 최소한의 컴포넌트 re-render만을 촉발하는 것...등의 이점을 얻을 수 있었다.
하지만 이로 인해 형제 컴포넌트간의 데이터 전달, 또는 자식 컴포넌트에서 부모 컴포넌트로의 데이터 전달을 매우 제한적이고 복잡한 방식을 통해서만 가능하도록 만들었다.
이러한 점을 해소하기 위해 redux / mobX등의 상태관리 라이브러리가 사용된다.

&nbsp;
&nbsp;

**상태관리 라이브러리를 사용하면 state를 사용하지 않아야 한다?**

&nbsp;

반은 맞고 반은 틀린 말이다. 컴포넌트 간 데이터를 주고 받아야 한다면, store를 통해 데이터를 관리하는 것이 좋다.
하지만, 하나의 컴포넌트 안에서만 사용되며, 그 데이터가 변경됨에 따라 re-render가 일어나야 한다면 state로 데이터를 관리해도 된다.

즉, 사용하지 않아도 되지만, 사용하면 안되는 것은 아니다.

**Redux의 구조**

&nbsp;

- 데이터 관리를 위한 **Store** (일종의 데이터 묶음)
  - store 내부에 존재하는 데이터 객체 - **State**
- State를 변경하는 동작 - **Action**
- Action의 실행 - **Dispatch**
- State는 불변하다 -> 따라서 값의 변화가 있을 때, State 객체 자체의 값이 바뀌는 것이 아닌 **Reducer**가 변경된 값의 새로운 객체를 생성하고, 새로 생성한 객체로 기존 State를 대체한다.

1. store 내부에 state를 선언한다.
2. store에 선언된 state를 변경하기 위한 action을 정의한다.
3. 정의된 action을 실행(dispatch)한다.
4. action에 정의된 대로 state가 변경된다.

- dispatch도 일종의 함수이므로, dispatch 실행 시 기록이 남는다.
- 따라서, dispatch 수행 시 남은 기록을 통해 에러를 찾기 쉽다.
- dispatch 기록이 모두 남기 때문에, 특정 action 전의 상태로 돌아가는 time machine 기능을 활용할 수 있다.
