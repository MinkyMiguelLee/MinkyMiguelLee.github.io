<h1 id="javascript---중요-function-모음">JavaScript - 중요 Function 모음</h1>

<h1 id="배열-중복-제거">배열 중복 제거</h1>

<h2 id="1-set를-이용하여-중복-제거"><strong>1. Set를 이용하여 중복 제거</strong></h2>

<p>Set은 중복 데이터 저장을 허용하지 않는 자료구조이다. 이 특성을 이용하여 배열의 모든 요소를 Set에 추가하면 중복이 저절로 제거가 된다. <code class="language-plaintext highlighter-rouge">new Set(arr)</code>는 배열의 데이터가 추가된 Set 객체가 생성되며, 중복은 허용되지 않기 때문에 1개의 요소만 추가된다. Set를 Array로 변경할 때는 <a href="https://codechacha.com/ko/javascript-concat-array/">Spread operator</a>를 이용하면 <code class="language-plaintext highlighter-rouge">[...set]</code>처럼 간단하게 변환할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const arr = ['A', 'B', 'C', 'A', 'B'];

const set = new Set(arr);
const newArr = [...set];
console.log(newArr)
</code></pre></div></div>

<p>Output:</p>

<p><code class="language-plaintext highlighter-rouge">[ 'A', 'B', 'C' ]</code></p>

<p>Set를 Array로 변환할 때 아래와 같이 <code class="language-plaintext highlighter-rouge">Array.from()</code>을 이용할 수도 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const arr = ['A', 'B', 'C', 'A', 'B'];
const newArr = Array.from(new Set(arr));
console.log(newArr)
</code></pre></div></div>

<h2 id="2-filter-indexof를-이용하여-중복-제거"><strong>2. filter(), indexOf()를 이용하여 중복 제거</strong></h2>

<p><code class="language-plaintext highlighter-rouge">filter()</code>와 <code class="language-plaintext highlighter-rouge">indexOf()</code>를 사용하여 중복을 제거할 수도 있다. <code class="language-plaintext highlighter-rouge">indexOf(element)</code>는 배열에서 요소의 Index를 리턴하는데, 중복된 값이 있을 때 낮은 Index를 리턴한다. 따라서 <code class="language-plaintext highlighter-rouge">indexOf(element) === index</code>가 true가 되는 경우는 하나 뿐이고, 다른 중복된 값은 false가 리턴되여 <code class="language-plaintext highlighter-rouge">filter()</code>에 의해 필터링된다. 참고로, <code class="language-plaintext highlighter-rouge">filter(lambda)</code>는 lambda가 true일 때 그 요소를 결과에 포함시킨다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const arr = ['A', 'B', 'C', 'A', 'B'];

const newArr = arr.filter((element, index) =&gt; arr.indexOf(element) === index);
console.log(newArr);
</code></pre></div></div>

<p>Output:</p>

<p><code class="language-plaintext highlighter-rouge">[ 'A', 'B', 'C' ]</code></p>

<h2 id="3-reduce를-이용하여-중복-제거"><strong>3. reduce()를 이용하여 중복 제거</strong></h2>

<p><code class="language-plaintext highlighter-rouge">reduce()</code>는 배열 요소의 값들을 순차적으로 순회하면서 하나의 값을 만드는 함수이다. 초기값 initialValue가 주어지면, 배열의 0번 index부터 연산을 수행하고, 그 결과를 다음 연산의 인자(accumulator)로 전달한다.</p>

<p>아래 예제는 <code class="language-plaintext highlighter-rouge">reduce()</code>로 중복을 제거하는 방법인데 accumulator에 추가 안된 요소라면 추가하고, 그렇지 않으면 추가하지 않다. 이것을 첫번째 요소부터 마지막 요소까지 순회하면서 수행한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const arr = ['A', 'B', 'C', 'A', 'B'];

const initialValue = []
const newArr = arr.reduce((acc, obj) =&gt; acc.includes(obj) ? acc : [...acc, obj], initialValue)
console.log(newArr)
</code></pre></div></div>

<p>Output:</p>

<p><code class="language-plaintext highlighter-rouge">[ 'A', 'B', 'C' ]</code></p>

<h2 id="4-for-루프를-이용하여-중복-제거"><strong>4. for 루프를 이용하여 중복 제거</strong></h2>

<p>반복문을 사용하여 모든 요소를 순회하고 중복된 값은 제거하도록 직접 구현할 수 있다. 아래 예제는 forEach를 사용하여 구현하였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const arr = ['A', 'B', 'C', 'A', 'B'];

const newArr = [];
arr.forEach((element) =&gt; {
  if (!newArr.includes(element)) {
    newArr.push(element);
  }
});
console.log(newArr);
</code></pre></div></div>

<p>Output:</p>

<p><code class="language-plaintext highlighter-rouge">[ 'A', 'B', 'C' ]</code></p>

<hr />

<h1 id="문자열-아스키-코드-관련">문자열 아스키 코드 관련</h1>

<ol>
  <li>String.charCodeAt(idx)</li>
  <li>String.fromCharCode(65, 83, 67, 73, 73); // ASCII</li>
</ol>

<hr />

<h1 id="reduce">Reduce</h1>

<h3 id="reduce-메서드란"><strong>Reduce 메서드란?</strong></h3>

<p>reduce 메서드는 map, forEach와 비슷하게 배열의 요소들을 순회하면서 반복적인 연산을 하는 메서드이지만, map과 forEach와는 조금 다른 부분들이 있다.</p>

<h3 id="문법"><strong>문법</strong></h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// reduce
const numbers = [1, 2, 3, 4];

numbers.reduce((누산값, 현재요소값, 현재요소의index, 현재배열) =&gt; {
  return 다음누산값;
}, 초기누산값);
</code></pre></div></div>

<h3 id="콜백-함수"><strong>콜백 함수</strong></h3>

<ul>
  <li>첫 번째는 map과 forEach처럼 콜백 함수를 전달받는데, 이 콜백 함수의 파라미터가 map, forEach와 조금 다르다.</li>
  <li>reduce 메서드가 특별한 이유는 바로 이 콜백 함수의 첫 번째 파라미터인데, reduce 메서드에서 이 <strong>콜백 함수가 동작할 때 return 하는 값이 다음 콜백 함수의 첫 번째 파라미터로 전달</strong>되는 것이다.
    <ul>
      <li>그러고 나서 <strong>마지막 콜백 함수가 동작한 이후의 return 값이 reduce 메서드의 return 값</strong>이 되는 것이다.</li>
      <li>나머지 2,3,4번째 파라미터는 map, forEach 메소드의 1,2,3번째 파라미터와 역할이 동일하다.</li>
      <li>그렇기 때문에 콜백 함수의 <strong>파라미터 생략은, 3,4번째 파라미터만 가능</strong>하다.</li>
    </ul>
  </li>
</ul>

<h3 id="참고"><strong>참고</strong></h3>

<p>참고로 reduce 메서드에서 초기값이라 불리는 두 번째 파라미터는 생략이 가능하다.</p>

<p>만약 두번째 파라미터를 생략하고 콜백 함수만 전달할 경우, <strong>배열의 첫 번째 요소(0번 index)가 초기값이 되어 동작</strong>하게 된다.</p>

<h3 id="참고-1"><strong>참고</strong></h3>

<p>참고로 reduce 메서드에서 초기값이라 불리는 두 번째 파라미터는 생략이 가능하다.</p>

<p>만약 두번째 파라미터를 생략하고 콜백 함수만 전달할 경우, <strong>배열의 첫 번째 요소(0번 index)가 초기값이 되어 동작</strong>하게 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const numbers = [1, 2, 3, 4];

const sum = numbers.reduceRight((acc, el, i) =&gt; {
  console.log(`index: ${i}`)
  console.log(`acc: ${acc}`);
  console.log(`el: ${el}`);

  return el + acc;
}, 0);

console.log(`-----------`);
console.log(`sum: ${sum}`);
</code></pre></div></div>

<h3 id="응용">응용</h3>

<p>배열의 평균값을 구하는 데 사용한 코드</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function calculator(list) {
    let answer = list.reduce((a, b) =&gt; a + b, 0) / list.length;
    // 배열의 모든 값을 더해준 후, 배열의 길이로 나누기... 초기값은 0
    return answer;
}
</code></pre></div></div>

<hr />

<h1 id="이중-function">이중 Function</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function solution(tag){
    return function subSol(text){
        return `&lt;${tag}&gt;${text}&lt;/${tag}&gt;`;
    }
}

console.log(solution('h1')('제목이다')) // &lt;h1&gt;제목이다&lt;/h1&gt;
</code></pre></div></div>

<hr />
