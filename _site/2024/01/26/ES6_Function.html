<h1 id="es6---function">ES6 - Function</h1>

<h1 id="강화된-함수의-기능">강화된 함수의 기능</h1>

<p>ES6 에서는 함수의 기능을 온전하게 완성했다고 볼 수 있다.</p>

<h2 id="1-매개변수에-추가된-기능">1. 매개변수에 추가된 기능</h2>

<h3 id="11-매개변수-기본값-default-parameter">1.1. 매개변수 기본값 (default parameter)</h3>

<p>ES6 부터 함수 매개변수에 기본값을 줄 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function ex(a = 1) {
    console.log({ a });
}

ex();      // { a: 1 }
</code></pre></div></div>

<p>기본값으로 함수 호출을 넣어줄 수도 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function getDefault() {
    return 1;
}

function ex(a = getDefault()) {
    console.log({ a });
}

ex();       // { a: 1 }
</code></pre></div></div>

<h3 id="12-나머지-매개변수-rest-parameter">1.2. 나머지 매개변수 (rest parameter)</h3>

<p>입력된 매개변수 중에서 특정 매개변수 외의 나머지는 배열로 만들어줄 수 있다.</p>

<p>매개변수 개수가 가변적일 때 유용하다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function ex(a, ...rest) {
    console.log({ a, rest });
}

ex(1, 2, 3);        // { a: 1, rest: [2, 3] }
</code></pre></div></div>

<h3 id="13-명명된-매개변수-named-parameter">1.3. 명명된 매개변수 (named parameter)</h3>

<p>객체 비구조화를 이용하여 매개변수의 이름을 명시적으로 사용하며 함수를 호출할 수 있다.</p>

<p>매개변수의 이름과 값을 동시에 적을 수 있기 때문에 가독성이 높다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function getValues1(numbers, greaterThan, lessThan) {
    console.log({ numbers, greaterThan, lessThan });
}

function getValues2({ numbers, greaterThan, lessThan }) {
    console.log({ numbers, greaterThan, lessThan });
}

const numbers = [10, 20, 30, 40];

getValues1(numbers, 5, 25);  // { numbers, greaterThan: 5, lessThan: 25 }
getValues2({ numbers, greaterThan: 5, lessThan: 25 });
// { numbers, greaterThan: 5, lessThan: 25 }
</code></pre></div></div>

<h3 id="14-선택적-매개변수-optional-parameter">1.4. 선택적 매개변수 (optional parameter)</h3>

<p>명명된 매개변수를 응용하면 선택적 매개변수를 사용할 수도 있다.</p>

<p><code class="language-plaintext highlighter-rouge">getValues1</code> 함수에서는 필요없는 매개변수가 있어도 undefined 로 값을 넣어주어야 한다.</p>

<p>매개변수의 값이 많아지면 일일히 undefined 를 넣어주어야 하고 가독성도 굉장히 떨어지게 된다.</p>

<p>하지만 <code class="language-plaintext highlighter-rouge">getValues2</code> 함수에서는 필요없는 매개변수는 코드로 적지 않고 필요한 매개변수만 넣어주면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getValues1(numbers, undefined, 25);
getValues2({ numbers, greaterThan: 5 });
getValues2({ numbers, lessThan: 25 });
</code></pre></div></div>

<h2 id="2-화살표-함수-arrow-function">2. 화살표 함수 (arrow function)</h2>

<p>ES6 에서는 화살표를 이용하여 함수를 정의하는 방법이 새로 추가되었다.</p>

<p>화살표 함수를 사용하면 함수를 간결하게 작성할 수 있다.</p>

<h3 id="21-한줄-사용">2.1. 한줄 사용</h3>

<p>화살표 함수는 한줄로도 간단하게 정의할 수 있다.</p>

<p>중괄호 블록을 사용하지 않고 바로 오른쪽에 정의하며, return 키워드를 명시적으로 정의하지 않아도 오른쪽에 있는 값이 리턴된다.</p>

<p>매개변수가 하나라면 소괄호도 생략 가능하다.</p>

<p>반환하는 값이 Object 라면 반드시 소괄호로 감싸야 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const add = (a, b) =&gt; a + b;
const add5 = a =&gt; a + 5; // 매개변수가 하나면 소괄호를 생략 가능하다.
const addAndReturnObject = (a, b) =&gt; ({ result: a+b });
// 반환값이 Object 라면 소괄호로 감싸준다.
const print = () =&gt; console.log("print");
</code></pre></div></div>

<h3 id="22-여러줄-사용">2.2. 여러줄 사용</h3>

<p>화살표 함수에 코드가 여러줄이라면 전체를 중괄호로 묶고 return 키워드를 사용한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const add = (a, b) =&gt; {
    if (a &lt;= 0 || b &lt;= 0) {
        throw new Error('must be positive number');
    }
    return a + b;
}
</code></pre></div></div>

<h3 id="23-this-와-arguments-가-바인딩-되지-않음">2.3. this 와 arguments 가 바인딩 되지 않음</h3>

<p>화살표 함수에서는 this 와 arguments 가 바인딩 되지 않는다.</p>

<p>만약 arguments 가 필요하다면 나머지 매개변수 (rest parameter) 를 사용한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const print = (...rest) =&gt; console.log(rest);
print(1, 2);        // [1, 2]
</code></pre></div></div>

<h3 id="24-this-바인딩-차이점">2.4. this 바인딩 차이점</h3>

<p>일반 함수는 호출되었을 때, 호출한 대상에 바인딩된다.</p>

<p>아래 코드를 통해 this 가 각각 어디를 바라보고 있는지 알 수 있다.</p>

<p>앞에 <code class="language-plaintext highlighter-rouge">f.</code> 를 붙여서 호출하면 this 가 func() 함수를 가리키고 있다.</p>

<p>하지만 다른 변수에 할당한 다음에 아무것도 붙이지 않고 호출하면 this 는 전역객체를 참조한다. (브라우저에서는 window)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function func() {
  this.value = 1;

  this.increase = function() {
    this.value++;
  };

  this.print = function() {
    console.log(this);
  };
}

const f = new func();
f.increase();
console.log(f.value);       // 2
f.print();                  // func { value: 2, increase: ƒ, print: ƒ }

const inc = f.increase;
const print = f.print;
inc();
console.log(f.value);       // 2
print();                    // Window { parent: Window, ... }
</code></pre></div></div>

<p>기존 ES5 에서는 이런 문제점을 우회하기 위해 클로저(closure) 라는 개념을 사용했다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function func() {
  this.value = 1;
  that = this;

  this.increase = function() {
    that.value++;
  };

  this.print = function() {
    console.log(that);
  };
}
</code></pre></div></div>

<p>일반 함수는 호출할 당시의 객체에 this 바인딩 되는 대신 화살표 함수는 가장 가까운 일반 함수를 참조한다.</p>

<p>따라서 함수를 어디에 재할당 하던지 항상 생성되었을 당시의 일반함수를 참조하게 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function func() {
  this.value = 1;

  this.increase = () =&gt; {
    this.value++;
  };

  this.print = () =&gt; {
    console.log(this);
  };
}

const f = new func();
f.increase();
console.log(f.value);       // 2
f.print();                  // func { value: 2, increase: ƒ, print: ƒ }

const inc = f.increase;
const print = f.print;
inc();
console.log(f.value);       // 3
print();                    // func { value: 2, increase: ƒ, print: ƒ }
</code></pre></div></div>
