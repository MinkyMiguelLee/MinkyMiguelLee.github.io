<h1 id="es6-비동기-프로그래밍-1---promise">ES6 비동기 프로그래밍 1 - Promise</h1>

<h1 id="프로미스-promise">프로미스 (Promise)</h1>

<p>프로미스는 비동기 상태를 값으로 다룰 수 있는 객체다.</p>

<p>프로미스가 사용되기 전에는 콜백 패턴이 많이 사용되었다.</p>

<p>그러다가 여러 가지 프로미스 라이브러리가 등장하면서 널리 사용되었고 ES6 에서는 프로미스가 자바스크립트 언어에 포함되었다.</p>

<h2 id="1-콜백callback-패턴의-문제">1. 콜백(Callback) 패턴의 문제</h2>

<p>자바스크립트에서는 비동기 프로그래밍의 한 가지 방법으로 콜백(callback) 패턴을 많이 사용했다.</p>

<p>하지만 콜백 패턴은 조금만 중첩되어도 코드가 복잡해지는 콜백 지옥(Callback Hell)을 만들어낸다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function display(data) {
  console.log("result: " + data);
}

function conactData(data) {
  parsedData = data.concat(" parsing");
  console.log(parsedData);
  display(parsedData);
}

function getData(callback) {
  data = "This is new Data";
  console.log(data);
  callback(data, display);
}

getData(parsing);
// This is new Data
// This is new Data parsing
// result: This is new Data parsing
</code></pre></div></div>

<p>위 코드는 프로미스를 사용하면 아래와 같이 좀더 보기 쉽게 바꿀 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const getData = new Promise((resolve, reject) =&gt; {
  data = "This is new Data";
  console.log(data);
  resolve(data);
})

getData
  .then(data =&gt; {
    // concatData
    parsedData = data.concat(" parsing");
    console.log(parsedData);
    return parsedData;
  })
  .then(data =&gt; {
    // display
    console.log("result: " + data);
    return data;
  })
// This is new Data
// This is new Data parsing
// result: This is new Data parsing
</code></pre></div></div>

<h2 id="2-프로미스의-세가지-상태">2. 프로미스의 세가지 상태</h2>

<p>프로미스는 다음 세 가지 상태 중 하나로 존재한다.</p>

<table>
  <thead>
    <tr>
      <th>상태</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>https://www.notion.so/8f4783a7cbe448ae822d686ad603420c?pvs=21</td>
      <td>결과를 기다리는중</td>
    </tr>
    <tr>
      <td>https://www.notion.so/8f4783a7cbe448ae822d686ad603420c?pvs=21</td>
      <td>수행이 정상적으로 끝났고 결과값을 갖고 있음</td>
    </tr>
    <tr>
      <td>https://www.notion.so/8f4783a7cbe448ae822d686ad603420c?pvs=21</td>
      <td>수행이 비정상적으로 끝났음</td>
    </tr>
  </tbody>
</table>

<p>그리고 이행됨, 거부됨 상태를 처리됨(settled) 상태라고 한다.</p>

<p>프로미스는 처리됨 상태가 되면 더 이상 다른 상태로 변경되지 않는다.</p>

<p>대기 중 상태일때만 이행됨 또는 거부됨 상태로 변할 수 있다.</p>

<h2 id="3-프로미스-생성">3. 프로미스 생성</h2>

<h3 id="31-new-키워드로-생성">3.1. new 키워드로 생성</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 1. new 키워드로 생성
const promise = new Promise((resolve, reject) =&gt; {
  // ..
  // resolve() or reject('error')
})
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">new</code> 키워드로 생성한 프로미스는 대기 중 상태가 된다.</p>

<p>생성자에 입력되는 <code class="language-plaintext highlighter-rouge">resolve</code> 와 <code class="language-plaintext highlighter-rouge">reject</code> 는 콜백 함수이다.</p>

<p><code class="language-plaintext highlighter-rouge">resolve</code> 를 호출하면 <code class="language-plaintext highlighter-rouge">promise</code> 는 이행됨 상태가 된다.</p>

<p>반대로 <code class="language-plaintext highlighter-rouge">reject</code> 를 호출하면 거부됨 상태가 된다.</p>

<p>만약 생성자에 입력된 함수 안에서 예외가 발생하면 거부됨 상태가 된다.</p>

<p><code class="language-plaintext highlighter-rouge">new</code> 키워드로 생성된 프로미스의 내부는 즉시 실행된다.</p>

<p>만약 API 요청을 보내는 비동기 코드가 있다면 프로미스가 생성되는 순간에 요청을 보낸다.</p>

<h3 id="32-promisereject-생성">3.2. Promise.reject 생성</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Promise.reject 로 생성
const promise = Promise.reject('error');
</code></pre></div></div>

<p>거부됨 상태인 프로미스를 생성한다.</p>

<h3 id="33-promiseresolve-생성">3.3. Promise.resolve 생성</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Promise.resolve 로 생성
const promise = Promise.resolve(params);

const p1 = Promise.resolve(123);
const p2 = Promise.resolve(p1);   // return p1
console.log(p2 === p1);           // true
</code></pre></div></div>

<p>입력값이 프로미스라면 그 객체가 그대로 반환되고, 프로미스가 아니라면 이행됨 상태인 프로미스가 반환된다.</p>

<h2 id="4-프로미스-사용">4. 프로미스 사용</h2>

<h3 id="41-then">4.1. then</h3>

<p><code class="language-plaintext highlighter-rouge">then</code> 은 처리됨 상태가 된 프로미스를 처리할 때 사용되는 메소드다.</p>

<p>프로미스가 처리됨 상태가 되면 <code class="language-plaintext highlighter-rouge">then</code> 메소드의 파라미터로 전달된 함수가 호출된다.</p>

<p><code class="language-plaintext highlighter-rouge">then</code> 메소드는 항상 프로미스를 반환하기 때문에 하나의 프로미스에서 연속적으로 <code class="language-plaintext highlighter-rouge">then</code> 메소드를 호출할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getData().then(onResolve, onReject);
</code></pre></div></div>

<p>만약에 함수 수행 중에 예외가 발생해서 거부됨 상태가 되면 <code class="language-plaintext highlighter-rouge">onReject</code> 함수가 존재하는 <code class="language-plaintext highlighter-rouge">then</code> 까지 이동한다.</p>

<p><code class="language-plaintext highlighter-rouge">onReject</code> 함수가 실행되고 나면 프로미스는 다시 이행됨 상태가 되어 4 다음에는 5 를 출력한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// print: 4 5
Promise.reject('error')
  .then(() =&gt; console.log('1'))
  .then(() =&gt; console.log('2'))
  .then(() =&gt; console.log('3'), () =&gt; console.log('4'))
  .then(() =&gt; console.log('5'));
</code></pre></div></div>

<h3 id="42-catch">4.2. catch</h3>

<p><code class="language-plaintext highlighter-rouge">catch</code> 는 프로미스 수행 중에 발생한 예외를 처리한다.</p>

<p><code class="language-plaintext highlighter-rouge">then</code> 함수의 <code class="language-plaintext highlighter-rouge">onReject</code> 와 같은 역할을 한다.</p>

<p>예외 처리는 <code class="language-plaintext highlighter-rouge">then</code> 보다 <code class="language-plaintext highlighter-rouge">catch</code> 함수를 사용하는 게 가독성이 더 좋다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Promise.reject('error').then(null, error =&gt; {
  console.log(error);
});

Promise.reject('error').catch(error =&gt; {
  console.log(error);
})
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">then</code> 은 <code class="language-plaintext highlighter-rouge">onResolve</code> 에서 에러가 발생했을 때 같은 함수 내에 있는 <code class="language-plaintext highlighter-rouge">onReject</code> 함수에서 처리할 수 없다.</p>

<p>하지만 <code class="language-plaintext highlighter-rouge">catch</code> 를 사용하면 처리가능하고 함수도 좀 더 직관적이다.</p>

<p><code class="language-plaintext highlighter-rouge">catch</code> 도 마찬가지로 프로미스를 반환하기 때문에 계속해서 체이닝을 이어나갈 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// onResolve 에서 에러가 발생해도 onReject 가 아닌 뒤에서 처리해야됨
Promise.resolve().then(onResolve, onReject);

// print: this is Error: then error
// print: success then 2
Promise.resolve()
  .then(() =&gt; {
    throw new Error('then error');
  })
  .catch(error =&gt; {
    console.log('this is ' + error);
    return 2;
  })
  .then(data =&gt; {
    console.log('success then: ' + data);
  });
</code></pre></div></div>

<h3 id="43-finally">4.3. finally</h3>

<p><code class="language-plaintext highlighter-rouge">finally</code> 는 프로미스가 처리됨(settled) 상태일 때 호출되는 함수이다.</p>

<p>프로미스 체인의 가장 마지막에 사용된다.</p>

<p><code class="language-plaintext highlighter-rouge">finally</code> 는 이전에 사용된 프로미스를 그대로 반환하기 때문에 처리됨 상태인 프로미스의 데이터를 건드리지 않고 추가 작업을 할 수 있다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// print: 123
// print: finish promise
Promise.resolve(123)
  .then(data =&gt; {
    console.log(data);
    return data;
  })
  .catch(error =&gt; {
    console.log(error);
    return error;
  })
  .finally(() =&gt; {
    console.log('finish promise');
  });
</code></pre></div></div>

<h2 id="5-프로미스-활용">5. 프로미스 활용</h2>

<p>다음 예제를 통해 <code class="language-plaintext highlighter-rouge">Promise</code> 를 활용하는 방법들을 알아본다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const getData1 = Promise.resolve(1);
const getData2 = new Promise((resolve, reject) =&gt;
  setTimeout(function() {
    console.log('3');
    resolve(2);
  }, 5000));
</code></pre></div></div>

<h3 id="51-promiseall-병렬-처리">5.1. Promise.all: 병렬 처리</h3>

<p><code class="language-plaintext highlighter-rouge">then</code> 함수를 체인으로 연결하면 각각의 비동기 로직이 병렬로 처리되지 않고 순차적으로 실행된다.</p>

<p>서로 간의 의존성이 없다면 병렬로 처리하는 게 더 빠르다.</p>

<p><code class="language-plaintext highlighter-rouge">Promise.all</code> 함수는 여러 개의 프로미스를 동시에 실행하며 프로미스가 모두 처리되면 처리됨 상태가 되고 하나라도 거부된다면 거부됨 상태가 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// print: 3   (5초 뒤 출력)
// print: 1 2
Promise
  .all([getData1, getData2])
  .then(([data1, data2]) =&gt; {
    console.log(data1, data2);
  });
</code></pre></div></div>

<h3 id="52-promiserace-가장-빨리-처리된-프로미스">5.2. Promise.race: 가장 빨리 처리된 프로미스</h3>

<p><code class="language-plaintext highlighter-rouge">Promise.race</code> 는 여러 개의 프로미스 중 가장 빨리 처리된 프로미스를 반환한다.</p>

<p>여러 개의 프로미스 중 하나라도 처리되면 처리됨 상태가 된다.</p>

<p>프로미스 간의 격차가 커서 먼저 <code class="language-plaintext highlighter-rouge">Promise.race</code> 가 실행 되더라도 다른 프로미스의 작업은 중지되지 않는다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// print: 1
// print: 3   (5초 뒤 출력)
Promise
  .race([getData1, getData2])
  .then(data =&gt; {
    console.log(data);
  });
</code></pre></div></div>
