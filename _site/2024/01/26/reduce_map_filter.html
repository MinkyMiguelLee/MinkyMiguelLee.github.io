<h1 id="reduce--map--filter">reduce / map / filter</h1>

<h3 id="for문">for문</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const practice = [
  { name: "개발자", value: 150, active: false },
  { name: "퉁이리", value: 200, active: true },
  { name: "프론트엔드", value: 110, active: true },
  { name: "티스토리", value: 300, active: true },
  { name: "깃허브", value: 250, active: true },
];

for (let i = 0; i &lt; practice.length; i++) {
  console.log(practice[i].name);
}
</code></pre></div></div>

<h3 id="while문">while문</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const practice = [
  { name: "개발자", value: 150, active: false },
  { name: "퉁이리", value: 200, active: true },
  { name: "프론트엔드", value: 110, active: true },
  { name: "티스토리", value: 300, active: true },
  { name: "깃허브", value: 250, active: true },
];

let i = 0;
while (i &lt; practice.length) {
  console.log(practice[i].name);
  i++;
}
</code></pre></div></div>

<ul>
  <li>while문도 마찬가지로 i를 활용하여 카운팅을 하고 practice 길이만큼만 반복하게 하였다.</li>
</ul>

<h3 id="foreach">forEach</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const practice = [
  { name: "개발자", value: 150, active: false },
  { name: "퉁이리", value: 200, active: true },
  { name: "프론트엔드", value: 110, active: true },
  { name: "티스토리", value: 300, active: true },
  { name: "깃허브", value: 250, active: true },
];

practice.forEach((data) =&gt; console.log(data.name));
</code></pre></div></div>

<ul>
  <li>forEach는 아주 단순한 반복문으로 별다른 부가기능은 없다는 특징이 있다.</li>
  <li>가장 기본적인 반복문이다.</li>
  <li>그렇지만 for문보다 코드가 더 예뻐 보인다.</li>
  <li>그 이유는 아래와 같다!
    <ul>
      <li>임시 변수(i)를 사용하지 않아도 된다.</li>
      <li>길이를 따로 설정하지 않아도 된다.</li>
    </ul>
  </li>
</ul>

<h3 id="map">map</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const practice = [
  { name: "개발자", value: 150, active: false },
  { name: "퉁이리", value: 200, active: true },
  { name: "프론트엔드", value: 110, active: true },
  { name: "티스토리", value: 300, active: true },
  { name: "깃허브", value: 250, active: true },
];

const practiceNames = practice.map((data) =&gt; data.name);

console.log(practiceNames);
</code></pre></div></div>

<ul>
  <li>map은 어떤 배열을 다른 형태의 배열로 재생산할 때 사용된다.</li>
  <li>기존 배열을 수정하는 것이 아니라 새 배열을 반환하는 것이다!</li>
  <li>map은 배열의재탄생을 도와준다.</li>
</ul>

<h3 id="filter">filter</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const practice = [
  { name: "개발자", value: 150, active: false },
  { name: "퉁이리", value: 200, active: true },
  { name: "프론트엔드", value: 110, active: true },
  { name: "티스토리", value: 300, active: true },
  { name: "깃허브", value: 250, active: true },
];

const practice220 = practice.filter((data) =&gt; data.value &lt; 220);

console.log(practice220);
</code></pre></div></div>

<ul>
  <li>filter는 배열 안에서 특정 조건을 가진 요소만 뽑아내는 반복문이다.</li>
  <li>filter도 map과 같이필터링을 통과한 값에 대해 새 배열을 반환한다.</li>
  <li>위 코드는 value의 값이 220 미만인 값에 대해 필터링을 진행 후 필터를 통과한 값으로 이루어진 배열을 반환하였다.</li>
  <li>검색 기능에서 많이 활용된다.</li>
</ul>

<h3 id="reduce">reduce</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const practice = [
  { name: "개발자", value: 150, active: false },
  { name: "퉁이리", value: 200, active: true },
  { name: "프론트엔드", value: 110, active: true },
  { name: "티스토리", value: 300, active: true },
  { name: "깃허브", value: 250, active: true },
];

const practiceSum = practice.reduce((pre, cur) =&gt; pre + cur.value, 0);

console.log(practiceSum);
</code></pre></div></div>

<ul>
  <li>practice에 있는 모든 value 값들의 합을 구하고 싶을 때, reduce를 사용한다.</li>
  <li>누적 합을 구할 때 reduce를 많이 사용한다.</li>
  <li>pre는 누산 값 cur은 현재 값 0은 초기 값</li>
  <li>reduce 메서드 역시 하나의 결괏값을반환한다.</li>
</ul>
